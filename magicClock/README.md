# 魔法时钟！

这是我的第一个JavaScript程序，学习+编写总耗时三天。非常感谢这道题让我接触到这门语言！

# 总览

我仅仅完成了magicClock.js的编写，其他文件没有做任何修改，包括index.html。

# 写Canvas的心得

## 初始化的渲染

渲染在页面加载时即会开始，一般来说，先画的内容会在下面，后画的会在上，而由于JS异步执行，导致一些内容的绘画顺序出现错误。一开始想用Promise修掉，后来发现setInterval即可有效解决这一问题。

另外，在绘制时，我考虑了额外的因素，比如比例适配。具体代码中例如`(canvas.height + clockboard.height) / 2 - minutehand.height + miny_offset`，可以确保即使Canvas的高度被修改，分针的孔依旧可以对准表盘中心。

## 角度的计算和旋转

由于这两个步骤很可能需要重复执行，所以我将它们封装成函数。

`angle_calc()`

角度计算的机制：根据时间计算角度，数学问题，没什么可讲的。

`angle_adjust(target, ed, center_x, center_y, offset)`

旋转的机制：在每一帧平移并旋转画布到指定位置，使指针的中心不变，并且转到计算得出的角度，再绘制。需要特别注意的是，绘制完成后需要把画布旋转回原来的角度，并且平移回原位，等待下一次绘制。`offset`和上面`miny_offset`的作用相同，都是使分针的孔对准表盘中心。

## 物体的交互

### 鼠标点击的判定

由于Canvas只负责画图，没有办法得知画完后某个东西的具体位置和大小，所以并不能直接使用像Unity中的Collider检测碰撞，而是需要模拟Collider。

需要检测的东西只有两个，也就是“表盘”和“插销”。它们分别可以用圆形和矩形代替。如果点击的范围位于内部，就算点到，否则算没点到。

鼠标点击使用`"mousedown"`判断。

### 鼠标松开的判定

鼠标松开使用`"mouseup"`判断。

### 鼠标拖动的判定

鼠标拖动的前提是鼠标已经按下并保持。为此，需要记录鼠标的状态，它被保存在`canvasInfo`中的`status`。

一般状态下，`status`为`IDLE`。

当`"mousedown"`时，修改`status`为`DRAG_START`。

当`"mouseup"`时，修改`status`为`IDLE`。

当`status`为`DRAG_START`时，即代表鼠标已经按下并保持。此时鼠标移动距离如果大于某个阈值，即修改`status`为`DRAGGING`。

鼠标拖动使用`"mousemove"`判断。

### Bolt的拖动

检测Bolt拖动，并且在下一帧渲染到指定位置。

为了让Bolt的拖动更为自然，特别限制了它y方向上移动的区域，并顺便实现了时停的效果。

为了防止在拖动刚开始时，Bolt产生瞬移，特别使用了offset_y记录鼠标位置和图片渲染中心的y方向偏移，在每次拖动时保持不变，在下一次拖动时刷新。

### ClockBoard的点击

根据坐标计算角度，并且使用上述自定义函数`angle_adjust(...)`来重绘指针。

经过测试，发现添加动画后，调整的角度就不再精确，所以暂时放弃动画。

# Question回答

### Q1

`npm start`命令用于启动服务器，`nodejs`用于运行JavaScript代码。

### Q2

`e.offsetX`和`e.offsetY`表示相对于某个东西（绑定了事件侦听器的元素），鼠标的坐标

`e.clientX`和`e.clientY`表示相对于浏览器窗口的可视区域的左上角的横纵坐标

### Q4

心得和体会见上

10分。参与感、表意清晰、拓展合理、引导适当……我想不出更好的词语了！

第一次写前端，写的好差啊（（（